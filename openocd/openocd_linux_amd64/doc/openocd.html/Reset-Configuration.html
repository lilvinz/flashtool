<html lang="en">
<head>
<title>Reset Configuration - OpenOCD User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="OpenOCD User's Guide">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="prev" href="Debug-Adapter-Configuration.html#Debug-Adapter-Configuration" title="Debug Adapter Configuration">
<link rel="next" href="TAP-Declaration.html#TAP-Declaration" title="TAP Declaration">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This User's Guide documents
release 0.7.0-dev,
dated 25 March 2013,
of the Open On-Chip Debugger (OpenOCD).
   * Copyright (C) 2008 The OpenOCD Project

   * Copyright (C) 2007-2008 Spencer Oliver <spen@spen-soft.co.uk>

   * Copyright (C) 2008-2010 Oyvind Harboe <oyvind.harboe@zylin.com>

   * Copyright (C) 2008 Duane Ellis <openocd@duaneellis.com>

   * Copyright (C) 2009-2010 David Brownell
     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with no Front-Cover Texts,
     and with no Back-Cover Texts.  A copy of the license is included
     in the section entitled ``GNU Free Documentation License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Reset-Configuration"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="TAP-Declaration.html#TAP-Declaration">TAP Declaration</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Debug-Adapter-Configuration.html#Debug-Adapter-Configuration">Debug Adapter Configuration</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="index.html#Top">Top</a>
<hr>
</div>

<h2 class="chapter">9 Reset Configuration</h2>

<p><a name="index-Reset-Configuration-137"></a>
Every system configuration may require a different reset
configuration. This can also be quite confusing. 
Resets also interact with <var>reset-init</var> event handlers,
which do things like setting up clocks and DRAM, and
JTAG clock rates.  (See <a href="JTAG-Speed.html#JTAG-Speed">JTAG Speed</a>.) 
They can also interact with JTAG routers. 
Please see the various board files for examples.

<blockquote>
<b>Note:</b> To maintainers and integrators:
Reset configuration touches several things at once. 
Normally the board configuration file
should define it and assume that the JTAG adapter supports
everything that's wired up to the board's JTAG connector.

<p>However, the target configuration file could also make note
of something the silicon vendor has done inside the chip,
which will be true for most (or all) boards using that chip. 
And when the JTAG adapter doesn't support everything, the
user configuration file will need to override parts of
the reset configuration provided by other files. 
</blockquote>

<h3 class="section">9.1 Types of Reset</h3>

<p>There are many kinds of reset possible through JTAG, but
they may not all work with a given board and adapter. 
That's part of why reset configuration can be error prone.

     <ul>
<li><em>System Reset</em> ... the <em>SRST</em> hardware signal
resets all chips connected to the JTAG adapter, such as processors,
power management chips, and I/O controllers.  Normally resets triggered
with this signal behave exactly like pressing a RESET button. 
<li><em>JTAG TAP Reset</em> ... the <em>TRST</em> hardware signal resets
just the TAP controllers connected to the JTAG adapter. 
Such resets should not be visible to the rest of the system; resetting a
device's TAP controller just puts that controller into a known state. 
<li><em>Emulation Reset</em> ... many devices can be reset through JTAG
commands.  These resets are often distinguishable from system
resets, either explicitly (a "reset reason" register says so)
or implicitly (not all parts of the chip get reset). 
<li><em>Other Resets</em> ... system-on-chip devices often support
several other types of reset. 
You may need to arrange that a watchdog timer stops
while debugging, preventing a watchdog reset. 
There may be individual module resets. 
</ul>

<p>In the best case, OpenOCD can hold SRST, then reset
the TAPs via TRST and send commands through JTAG to halt the
CPU at the reset vector before the 1st instruction is executed. 
Then when it finally releases the SRST signal, the system is
halted under debugger control before any code has executed. 
This is the behavior required to support the <samp><span class="command">reset halt</span></samp>
and <samp><span class="command">reset init</span></samp> commands; after <samp><span class="command">reset init</span></samp> a
board-specific script might do things like setting up DRAM. 
(See <a href="Reset-Command.html#Reset-Command">Reset Command</a>.)

<p><a name="SRST-and-TRST-Issues"></a>

<h3 class="section">9.2 SRST and TRST Issues</h3>

<p>Because SRST and TRST are hardware signals, they can have a
variety of system-specific constraints.  Some of the most
common issues are:

     <ul>
<li><em>Signal not available</em> ... Some boards don't wire
SRST or TRST to the JTAG connector.  Some JTAG adapters don't
support such signals even if they are wired up. 
Use the <samp><span class="command">reset_config</span></samp> <var>signals</var> options to say
when either of those signals is not connected. 
When SRST is not available, your code might not be able to rely
on controllers having been fully reset during code startup. 
Missing TRST is not a problem, since JTAG-level resets can
be triggered using with TMS signaling.

     <li><em>Signals shorted</em> ... Sometimes a chip, board, or
adapter will connect SRST to TRST, instead of keeping them separate. 
Use the <samp><span class="command">reset_config</span></samp> <var>combination</var> options to say
when those signals aren't properly independent.

     <li><em>Timing</em> ... Reset circuitry like a resistor/capacitor
delay circuit, reset supervisor, or on-chip features can extend
the effect of a JTAG adapter's reset for some time after the adapter
stops issuing the reset.  For example, there may be chip or board
requirements that all reset pulses last for at least a
certain amount of time; and reset buttons commonly have
hardware debouncing. 
Use the <samp><span class="command">adapter_nsrst_delay</span></samp> and <samp><span class="command">jtag_ntrst_delay</span></samp>
commands to say when extra delays are needed.

     <li><em>Drive type</em> ... Reset lines often have a pullup
resistor, letting the JTAG interface treat them as open-drain
signals.  But that's not a requirement, so the adapter may need
to use push/pull output drivers. 
Also, with weak pullups it may be advisable to drive
signals to both levels (push/pull) to minimize rise times. 
Use the <samp><span class="command">reset_config</span></samp> <var>trst_type</var> and
<var>srst_type</var> parameters to say how to drive reset signals.

     <li><em>Special initialization</em> ...  Targets sometimes need
special JTAG initialization sequences to handle chip-specific
issues (not limited to errata). 
For example, certain JTAG commands might need to be issued while
the system as a whole is in a reset state (SRST active)
but the JTAG scan chain is usable (TRST inactive). 
Many systems treat combined assertion of SRST and TRST as a
trigger for a harder reset than SRST alone. 
Such custom reset handling is discussed later in this chapter. 
</ul>

<p>There can also be other issues. 
Some devices don't fully conform to the JTAG specifications. 
Trivial system-specific differences are common, such as
SRST and TRST using slightly different names. 
There are also vendors who distribute key JTAG documentation for
their chips only to developers who have signed a Non-Disclosure
Agreement (NDA).

<p>Sometimes there are chip-specific extensions like a requirement to use
the normally-optional TRST signal (precluding use of JTAG adapters which
don't pass TRST through), or needing extra steps to complete a TAP reset.

<p>In short, SRST and especially TRST handling may be very finicky,
needing to cope with both architecture and board specific constraints.

<h3 class="section">9.3 Commands for Handling Resets</h3>

<div class="defun">
&mdash; Command: <b>adapter_nsrst_assert_width</b><var> milliseconds<a name="index-adapter_005fnsrst_005fassert_005fwidth-138"></a></var><br>
<blockquote><p>Minimum amount of time (in milliseconds) OpenOCD should wait
after asserting nSRST (active-low system reset) before
allowing it to be deasserted. 
</p></blockquote></div>

<div class="defun">
&mdash; Command: <b>adapter_nsrst_delay</b><var> milliseconds<a name="index-adapter_005fnsrst_005fdelay-139"></a></var><br>
<blockquote><p>How long (in milliseconds) OpenOCD should wait after deasserting
nSRST (active-low system reset) before starting new JTAG operations. 
When a board has a reset button connected to SRST line it will
probably have hardware debouncing, implying you should use this. 
</p></blockquote></div>

<div class="defun">
&mdash; Command: <b>jtag_ntrst_assert_width</b><var> milliseconds<a name="index-jtag_005fntrst_005fassert_005fwidth-140"></a></var><br>
<blockquote><p>Minimum amount of time (in milliseconds) OpenOCD should wait
after asserting nTRST (active-low JTAG TAP reset) before
allowing it to be deasserted. 
</p></blockquote></div>

<div class="defun">
&mdash; Command: <b>jtag_ntrst_delay</b><var> milliseconds<a name="index-jtag_005fntrst_005fdelay-141"></a></var><br>
<blockquote><p>How long (in milliseconds) OpenOCD should wait after deasserting
nTRST (active-low JTAG TAP reset) before starting new JTAG operations. 
</p></blockquote></div>

<div class="defun">
&mdash; Command: <b>reset_config</b><var> mode_flag ...<a name="index-reset_005fconfig-142"></a></var><br>
<blockquote><p>This command displays or modifies the reset configuration
of your combination of JTAG board and target in target
configuration scripts.

     <p>Information earlier in this section describes the kind of problems
the command is intended to address (see <a href="SRST-and-TRST-Issues.html#SRST-and-TRST-Issues">SRST and TRST Issues</a>). 
As a rule this command belongs only in board config files,
describing issues like <em>board doesn't connect TRST</em>;
or in user config files, addressing limitations derived
from a particular combination of interface and board. 
(An unlikely example would be using a TRST-only adapter
with a board that only wires up SRST.)

     <p>The <var>mode_flag</var> options can be specified in any order, but only one
of each type &ndash; <var>signals</var>, <var>combination</var>, <var>gates</var>,
<var>trst_type</var>, <var>srst_type</var> and <var>connect_type</var>
&ndash; may be specified at a time. 
If you don't provide a new value for a given type, its previous
value (perhaps the default) is unchanged. 
For example, this means that you don't need to say anything at all about
TRST just to declare that if the JTAG adapter should want to drive SRST,
it must explicitly be driven high (<samp><span class="option">srst_push_pull</span></samp>).

          <ul>
<li><var>signals</var> can specify which of the reset signals are connected. 
For example, If the JTAG interface provides SRST, but the board doesn't
connect that signal properly, then OpenOCD can't use it. 
Possible values are <samp><span class="option">none</span></samp> (the default), <samp><span class="option">trst_only</span></samp>,
<samp><span class="option">srst_only</span></samp> and <samp><span class="option">trst_and_srst</span></samp>.

          <blockquote>
<b>Tip:</b> If your board provides SRST and/or TRST through the JTAG connector,
you must declare that so those signals can be used. 
</blockquote>

          <li>The <var>combination</var> is an optional value specifying broken reset
signal implementations. 
The default behaviour if no option given is <samp><span class="option">separate</span></samp>,
indicating everything behaves normally. 
<samp><span class="option">srst_pulls_trst</span></samp> states that the
test logic is reset together with the reset of the system (e.g. NXP
LPC2000, "broken" board layout), <samp><span class="option">trst_pulls_srst</span></samp> says that
the system is reset together with the test logic (only hypothetical, I
haven't seen hardware with such a bug, and can be worked around). 
<samp><span class="option">combined</span></samp> implies both <samp><span class="option">srst_pulls_trst</span></samp> and
<samp><span class="option">trst_pulls_srst</span></samp>.

          <li>The <var>gates</var> tokens control flags that describe some cases where
JTAG may be unvailable during reset. 
<samp><span class="option">srst_gates_jtag</span></samp> (default)
indicates that asserting SRST gates the
JTAG clock. This means that no communication can happen on JTAG
while SRST is asserted. 
Its converse is <samp><span class="option">srst_nogate</span></samp>, indicating that JTAG commands
can safely be issued while SRST is active.

          <li>The <var>connect_type</var> tokens control flags that describe some cases where
SRST is asserted while connecting to the target. <samp><span class="option">srst_nogate</span></samp>
is required to use this option. 
<samp><span class="option">connect_deassert_srst</span></samp> (default)
indicates that SRST will not be asserted while connecting to the target. 
Its converse is <samp><span class="option">connect_assert_srst</span></samp>, indicating that SRST will
be asserted before any target connection. 
Only some targets support this feature, STM32 and STR9 are examples. 
This feature is useful if you are unable to connect to your target due
to incorrect options byte config or illegal program execution. 
</ul>

     <p>The optional <var>trst_type</var> and <var>srst_type</var> parameters allow the
driver mode of each reset line to be specified.  These values only affect
JTAG interfaces with support for different driver modes, like the Amontec
JTAGkey and JTAG Accelerator.  Also, they are necessarily ignored if the
relevant signal (TRST or SRST) is not connected.

          <ul>
<li>Possible <var>trst_type</var> driver modes for the test reset signal (TRST)
are the default <samp><span class="option">trst_push_pull</span></samp>, and <samp><span class="option">trst_open_drain</span></samp>. 
Most boards connect this signal to a pulldown, so the JTAG TAPs
never leave reset unless they are hooked up to a JTAG adapter.

          <li>Possible <var>srst_type</var> driver modes for the system reset signal (SRST)
are the default <samp><span class="option">srst_open_drain</span></samp>, and <samp><span class="option">srst_push_pull</span></samp>. 
Most boards connect this signal to a pullup, and allow the
signal to be pulled low by various events including system
powerup and pressing a reset button. 
</ul>
     </p></blockquote></div>

<h3 class="section">9.4 Custom Reset Handling</h3>

<p><a name="index-events-143"></a>
OpenOCD has several ways to help support the various reset
mechanisms provided by chip and board vendors. 
The commands shown in the previous section give standard parameters. 
There are also <em>event handlers</em> associated with TAPs or Targets. 
Those handlers are Tcl procedures you can provide, which are invoked
at particular points in the reset sequence.

<p><em>When SRST is not an option</em> you must set
up a <code>reset-assert</code> event handler for your target. 
For example, some JTAG adapters don't include the SRST signal;
and some boards have multiple targets, and you won't always
want to reset everything at once.

<p>After configuring those mechanisms, you might still
find your board doesn't start up or reset correctly. 
For example, maybe it needs a slightly different sequence
of SRST and/or TRST manipulations, because of quirks that
the <samp><span class="command">reset_config</span></samp> mechanism doesn't address;
or asserting both might trigger a stronger reset, which
needs special attention.

<p>Experiment with lower level operations, such as <samp><span class="command">jtag_reset</span></samp>
and the <samp><span class="command">jtag arp_*</span></samp> operations shown here,
to find a sequence of operations that works. 
See <a href="JTAG-Commands.html#JTAG-Commands">JTAG Commands</a>. 
When you find a working sequence, it can be used to override
<samp><span class="command">jtag_init</span></samp>, which fires during OpenOCD startup
(see <a href="Configuration-Stage.html#Configuration-Stage">Configuration Stage</a>);
or <samp><span class="command">init_reset</span></samp>, which fires during reset processing.

<p>You might also want to provide some project-specific reset
schemes.  For example, on a multi-target board the standard
<samp><span class="command">reset</span></samp> command would reset all targets, but you
may need the ability to reset only one target at time and
thus want to avoid using the board-wide SRST signal.

<div class="defun">
&mdash; Overridable Procedure: <b>init_reset</b><var> mode<a name="index-init_005freset-144"></a></var><br>
<blockquote><p>This is invoked near the beginning of the <samp><span class="command">reset</span></samp> command,
usually to provide as much of a cold (power-up) reset as practical. 
By default it is also invoked from <samp><span class="command">jtag_init</span></samp> if
the scan chain does not respond to pure JTAG operations. 
The <var>mode</var> parameter is the parameter given to the
low level reset command (<samp><span class="option">halt</span></samp>,
<samp><span class="option">init</span></samp>, or <samp><span class="option">run</span></samp>), <samp><span class="option">setup</span></samp>,
or potentially some other value.

     <p>The default implementation just invokes <samp><span class="command">jtag arp_init-reset</span></samp>. 
Replacements will normally build on low level JTAG
operations such as <samp><span class="command">jtag_reset</span></samp>. 
Operations here must not address individual TAPs
(or their associated targets)
until the JTAG scan chain has first been verified to work.

     <p>Implementations must have verified the JTAG scan chain before
they return. 
This is done by calling <samp><span class="command">jtag arp_init</span></samp>
(or <samp><span class="command">jtag arp_init-reset</span></samp>). 
</p></blockquote></div>

<div class="defun">
&mdash; Command: <b>jtag arp_init</b><var><a name="index-jtag-arp_005finit-145"></a></var><br>
<blockquote><p>This validates the scan chain using just the four
standard JTAG signals (TMS, TCK, TDI, TDO). 
It starts by issuing a JTAG-only reset. 
Then it performs checks to verify that the scan chain configuration
matches the TAPs it can observe. 
Those checks include checking IDCODE values for each active TAP,
and verifying the length of their instruction registers using
TAP <code>-ircapture</code> and <code>-irmask</code> values. 
If these tests all pass, TAP <code>setup</code> events are
issued to all TAPs with handlers for that event. 
</p></blockquote></div>

<div class="defun">
&mdash; Command: <b>jtag arp_init-reset</b><var><a name="index-jtag-arp_005finit_002dreset-146"></a></var><br>
<blockquote><p>This uses TRST and SRST to try resetting
everything on the JTAG scan chain
(and anything else connected to SRST). 
It then invokes the logic of <samp><span class="command">jtag arp_init</span></samp>. 
</p></blockquote></div>

</body></html>

