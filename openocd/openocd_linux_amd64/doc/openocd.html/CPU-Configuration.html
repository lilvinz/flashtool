<html lang="en">
<head>
<title>CPU Configuration - OpenOCD User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="OpenOCD User's Guide">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="prev" href="TAP-Declaration.html#TAP-Declaration" title="TAP Declaration">
<link rel="next" href="Flash-Commands.html#Flash-Commands" title="Flash Commands">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This User's Guide documents
release 0.7.0-dev,
dated 25 March 2013,
of the Open On-Chip Debugger (OpenOCD).
   * Copyright (C) 2008 The OpenOCD Project

   * Copyright (C) 2007-2008 Spencer Oliver <spen@spen-soft.co.uk>

   * Copyright (C) 2008-2010 Oyvind Harboe <oyvind.harboe@zylin.com>

   * Copyright (C) 2008 Duane Ellis <openocd@duaneellis.com>

   * Copyright (C) 2009-2010 David Brownell
     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with no Front-Cover Texts,
     and with no Back-Cover Texts.  A copy of the license is included
     in the section entitled ``GNU Free Documentation License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="CPU-Configuration"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Flash-Commands.html#Flash-Commands">Flash Commands</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="TAP-Declaration.html#TAP-Declaration">TAP Declaration</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="index.html#Top">Top</a>
<hr>
</div>

<h2 class="chapter">11 CPU Configuration</h2>

<p><a name="index-GDB-target-166"></a>
This chapter discusses how to set up GDB debug targets for CPUs. 
You can also access these targets without GDB
(see <a href="Architecture-and-Core-Commands.html#Architecture-and-Core-Commands">Architecture and Core Commands</a>,
and <a href="Target-State-handling.html#Target-State-handling">Target State handling</a>) and
through various kinds of NAND and NOR flash commands. 
If you have multiple CPUs you can have multiple such targets.

<p>We'll start by looking at how to examine the targets you have,
then look at how to add one more target and how to configure it.

<h3 class="section">11.1 Target List</h3>

<p><a name="index-target_002c-current-167"></a><a name="index-target_002c-list-168"></a>
All targets that have been set up are part of a list,
where each member has a name. 
That name should normally be the same as the TAP name. 
You can display the list with the <samp><span class="command">targets</span></samp>
(plural!) command. 
This display often has only one CPU; here's what it might
look like with more than one:
<pre class="verbatim">    TargetName         Type       Endian TapName            State
--  ------------------ ---------- ------ ------------------ ------------
 0* at91rm9200.cpu     arm920t    little at91rm9200.cpu     running
 1  MyTarget           cortex_m3  little mychip.foo         tap-disabled
</pre>

<p>One member of that list is the <dfn>current target</dfn>, which
is implicitly referenced by many commands. 
It's the one marked with a <code>*</code> near the target name. 
In particular, memory addresses often refer to the address
space seen by that current target. 
Commands like <samp><span class="command">mdw</span></samp> (memory display words)
and <samp><span class="command">flash erase_address</span></samp> (erase NOR flash blocks)
are examples; and there are many more.

<p>Several commands let you examine the list of targets:

<div class="defun">
&mdash; Command: <b>target count</b><var><a name="index-target-count-169"></a></var><br>
<blockquote><p><em>Note: target numbers are deprecated; don't use them. 
They will be removed shortly after August 2010, including this command. 
Iterate target using </em><samp><span class="command">target names</span></samp><em>, not by counting.</em>

     <p>Returns the number of targets, N. 
The highest numbered target is N - 1.
     <pre class="example">          set c [target count]
          for { set x 0 } { $x &lt; $c } { incr x } {
              # Assuming you have created this function
              print_target_details $x
          }
</pre>
     </blockquote></div>

<div class="defun">
&mdash; Command: <b>target current</b><var><a name="index-target-current-170"></a></var><br>
<blockquote><p>Returns the name of the current target. 
</p></blockquote></div>

<div class="defun">
&mdash; Command: <b>target names</b><var><a name="index-target-names-171"></a></var><br>
<blockquote><p>Lists the names of all current targets in the list.
     <pre class="example">          foreach t [target names] {
              puts [format "Target: %s\n" $t]
          }
</pre>
     </blockquote></div>

<div class="defun">
&mdash; Command: <b>target number</b><var> number<a name="index-target-number-172"></a></var><br>
<blockquote><p><em>Note: target numbers are deprecated; don't use them. 
They will be removed shortly after August 2010, including this command.</em>

     <p>The list of targets is numbered starting at zero. 
This command returns the name of the target at index <var>number</var>.
     <pre class="example">          set thename [target number $x]
          puts [format "Target %d is: %s\n" $x $thename]
</pre>
     </blockquote></div>

<!-- yep, "target list" would have been better. -->
<!-- plus maybe "target setdefault". -->
<div class="defun">
&mdash; Command: <b>targets</b> [<var>name</var>]<var><a name="index-targets-173"></a></var><br>
<blockquote><p><em>Note: the name of this command is plural.  Other target
command names are singular.</em>

     <p>With no parameter, this command displays a table of all known
targets in a user friendly form.

     <p>With a parameter, this command sets the current target to
the given target with the given <var>name</var>; this is
only relevant on boards which have more than one target. 
</p></blockquote></div>

<h3 class="section">11.2 Target CPU Types and Variants</h3>

<p><a name="index-target-type-174"></a><a name="index-CPU-type-175"></a><a name="index-CPU-variant-176"></a>
Each target has a <dfn>CPU type</dfn>, as shown in the output of
the <samp><span class="command">targets</span></samp> command.  You need to specify that type
when calling <samp><span class="command">target create</span></samp>. 
The CPU type indicates more than just the instruction set. 
It also indicates how that instruction set is implemented,
what kind of debug support it integrates,
whether it has an MMU (and if so, what kind),
what core-specific commands may be available
(see <a href="Architecture-and-Core-Commands.html#Architecture-and-Core-Commands">Architecture and Core Commands</a>),
and more.

<p>For some CPU types, OpenOCD also defines <dfn>variants</dfn> which
indicate differences that affect their handling. 
For example, a particular implementation bug might need to be
worked around in some chip versions.

<p>It's easy to see what target types are supported,
since there's a command to list them. 
However, there is currently no way to list what target variants
are supported (other than by reading the OpenOCD source code).

<p><a name="target-types"></a>

<div class="defun">
&mdash; Command: <b>target types</b><var><a name="index-target-types-177"></a></var><br>
<blockquote><p>Lists all supported target types. 
At this writing, the supported CPU types and variants are:

          <ul>
<li><code>arm11</code> &ndash; this is a generation of ARMv6 cores
<li><code>arm720t</code> &ndash; this is an ARMv4 core with an MMU
<li><code>arm7tdmi</code> &ndash; this is an ARMv4 core
<li><code>arm920t</code> &ndash; this is an ARMv4 core with an MMU
<li><code>arm926ejs</code> &ndash; this is an ARMv5 core with an MMU
<li><code>arm966e</code> &ndash; this is an ARMv5 core
<li><code>arm9tdmi</code> &ndash; this is an ARMv4 core
<li><code>avr</code> &ndash; implements Atmel's 8-bit AVR instruction set. 
(Support for this is preliminary and incomplete.) 
<li><code>cortex_a8</code> &ndash; this is an ARMv7 core with an MMU
<li><code>cortex_m3</code> &ndash; this is an ARMv7 core, supporting only the
compact Thumb2 instruction set. 
<li><code>dragonite</code> &ndash; resembles arm966e
<li><code>dsp563xx</code> &ndash; implements Freescale's 24-bit DSP. 
(Support for this is still incomplete.) 
<li><code>fa526</code> &ndash; resembles arm920 (w/o Thumb)
<li><code>feroceon</code> &ndash; resembles arm926
<li><code>mips_m4k</code> &ndash; a MIPS core.  This supports one variant:
<li><code>xscale</code> &ndash; this is actually an architecture,
not a CPU type.  It is based on the ARMv5 architecture. 
There are several variants defined:
               <ul>
<li><code>ixp42x</code>, <code>ixp45x</code>, <code>ixp46x</code>,
<code>pxa27x</code> ... instruction register length is 7 bits
<li><code>pxa250</code>, <code>pxa255</code>,
<code>pxa26x</code> ... instruction register length is 5 bits
<li><code>pxa3xx</code> ... instruction register length is 11 bits
</ul>
          </ul>
     </p></blockquote></div>

<p>To avoid being confused by the variety of ARM based cores, remember
this key point: <em>ARM is a technology licencing company</em>. 
(See: <a href="http://www.arm.com">http://www.arm.com</a>.) 
The CPU name used by OpenOCD will reflect the CPU design that was
licenced, not a vendor brand which incorporates that design. 
Name prefixes like arm7, arm9, arm11, and cortex
reflect design generations;
while names like ARMv4, ARMv5, ARMv6, and ARMv7
reflect an architecture version implemented by a CPU design.

<p><a name="Target-Configuration"></a>

<h3 class="section">11.3 Target Configuration</h3>

<p>Before creating a &ldquo;target&rdquo;, you must have added its TAP to the scan chain. 
When you've added that TAP, you will have a <code>dotted.name</code>
which is used to set up the CPU support. 
The chip-specific configuration file will normally configure its CPU(s)
right after it adds all of the chip's TAPs to the scan chain.

<p>Although you can set up a target in one step, it's often clearer if you
use shorter commands and do it in two steps:  create it, then configure
optional parts. 
All operations on the target after it's created will use a new
command, created as part of target creation.

<p>The two main things to configure after target creation are
a work area, which usually has target-specific defaults even
if the board setup code overrides them later;
and event handlers (see <a href="Target-Events.html#Target-Events">Target Events</a>), which tend
to be much more board-specific. 
The key steps you use might look something like this

<pre class="example">     target create MyTarget cortex_m3 -chain-position mychip.cpu
     $MyTarget configure -work-area-phys 0x08000 -work-area-size 8096
     $MyTarget configure -event reset-deassert-pre { jtag_rclk 5 }
     $MyTarget configure -event reset-init { myboard_reinit }
</pre>
<p>You should specify a working area if you can; typically it uses some
on-chip SRAM. 
Such a working area can speed up many things, including bulk
writes to target memory;
flash operations like checking to see if memory needs to be erased;
GDB memory checksumming;
and more.

<blockquote>
<b>Warning:</b> On more complex chips, the work area can become
inaccessible when application code
(such as an operating system)
enables or disables the MMU. 
For example, the particular MMU context used to acess the virtual
address will probably matter ... and that context might not have
easy access to other addresses needed. 
At this writing, OpenOCD doesn't have much MMU intelligence. 
</blockquote>

<p>It's often very useful to define a <code>reset-init</code> event handler. 
For systems that are normally used with a boot loader,
common tasks include updating clocks and initializing memory
controllers. 
That may be needed to let you write the boot loader into flash,
in order to &ldquo;de-brick&rdquo; your board; or to load programs into
external DDR memory without having run the boot loader.

<div class="defun">
&mdash; Command: <b>target create</b><var> target_name type configparams...<a name="index-target-create-178"></a></var><br>
<blockquote><p>This command creates a GDB debug target that refers to a specific JTAG tap. 
It enters that target into a list, and creates a new
command (<samp><var>target_name</var></samp>) which is used for various
purposes including additional configuration.

          <ul>
<li><var>target_name</var> ...  is the name of the debug target. 
By convention this should be the same as the <em>dotted.name</em>
of the TAP associated with this target, which must be specified here
using the <code>-chain-position </code><var>dotted.name</var> configparam.

          <p>This name is also used to create the target object command,
referred to here as <samp><span class="command">$target_name</span></samp>,
and in other places the target needs to be identified. 
<li><var>type</var> ... specifies the target type.  See <a href="target-types.html#target-types">target types</a>. 
<li><var>configparams</var> ...  all parameters accepted by
<samp><span class="command">$target_name configure</span></samp> are permitted. 
If the target is big-endian, set it here with <code>-endian big</code>. 
If the variant matters, set it here with <code>-variant</code>.

          <p>You <em>must</em> set the <code>-chain-position </code><var>dotted.name</var> here. 
</ul>
     </p></blockquote></div>

<div class="defun">
&mdash; Command: <b>$target_name configure</b><var> configparams...<a name="index-g_t_0024target_005fname-configure-179"></a></var><br>
<blockquote><p>The options accepted by this command may also be
specified as parameters to <samp><span class="command">target create</span></samp>. 
Their values can later be queried one at a time by
using the <samp><span class="command">$target_name cget</span></samp> command.

     <p><em>Warning:</em> changing some of these after setup is dangerous. 
For example, moving a target from one TAP to another;
and changing its endianness or variant.

          <ul>
<li><code>-chain-position</code> <var>dotted.name</var> &ndash; names the TAP
used to access this target.

          <li><code>-endian</code> (<samp><span class="option">big</span></samp>|<samp><span class="option">little</span></samp>) &ndash; specifies
whether the CPU uses big or little endian conventions

          <li><code>-event</code> <var>event_name</var> <var>event_body</var> &ndash;
See <a href="Target-Events.html#Target-Events">Target Events</a>. 
Note that this updates a list of named event handlers. 
Calling this twice with two different event names assigns
two different handlers, but calling it twice with the
same event name assigns only one handler.

          <li><code>-variant</code> <var>name</var> &ndash; specifies a variant of the target,
which OpenOCD needs to know about.

          <li><code>-work-area-backup</code> (<samp><span class="option">0</span></samp>|<samp><span class="option">1</span></samp>) &ndash; says
whether the work area gets backed up; by default,
<em>it is not backed up.</em>
When possible, use a working_area that doesn't need to be backed up,
since performing a backup slows down operations. 
For example, the beginning of an SRAM block is likely to
be used by most build systems, but the end is often unused.

          <li><code>-work-area-size</code> <var>size</var> &ndash; specify work are size,
in bytes.  The same size applies regardless of whether its physical
or virtual address is being used.

          <li><code>-work-area-phys</code> <var>address</var> &ndash; set the work area
base <var>address</var> to be used when no MMU is active.

          <li><code>-work-area-virt</code> <var>address</var> &ndash; set the work area
base <var>address</var> to be used when an MMU is active. 
<em>Do not specify a value for this except on targets with an MMU.</em>
The value should normally correspond to a static mapping for the
<code>-work-area-phys</code> address, set up by the current operating system.

          <li><code>-rtos</code> <var>rtos_type</var> &ndash; enable rtos support for target,
<var>rtos_type</var> can be one of <samp><span class="option">auto</span></samp>|<samp><span class="option">eCos</span></samp>|<samp><span class="option">ThreadX</span></samp>|
<samp><span class="option">FreeRTOS</span></samp>|<samp><span class="option">linux</span></samp>|<samp><span class="option">ChibiOS</span></samp>.

     </ul>
     </p></blockquote></div>

<h3 class="section">11.4 Other $target_name Commands</h3>

<p><a name="index-object-command-180"></a>
The Tcl/Tk language has the concept of object commands,
and OpenOCD adopts that same model for targets.

<p>A good Tk example is a on screen button. 
Once a button is created a button
has a name (a path in Tk terms) and that name is useable as a first
class command. For example in Tk, one can create a button and later
configure it like this:

<pre class="example">     # Create
     button .foobar -background red -command { foo }
     # Modify
     .foobar configure -foreground blue
     # Query
     set x [.foobar cget -background]
     # Report
     puts [format "The button is %s" $x]
</pre>
<p>In OpenOCD's terms, the &ldquo;target&rdquo; is an object just like a Tcl/Tk
button, and its object commands are invoked the same way.

<pre class="example">     str912.cpu    mww 0x1234 0x42
     omap3530.cpu  mww 0x5555 123
</pre>
<p>The commands supported by OpenOCD target objects are:

<div class="defun">
&mdash; Command: <b>$target_name arp_examine</b><var><a name="index-g_t_0024target_005fname-arp_005fexamine-181"></a></var><br>
&mdash; Command: <b>$target_name arp_halt</b><var><a name="index-g_t_0024target_005fname-arp_005fhalt-182"></a></var><br>
&mdash; Command: <b>$target_name arp_poll</b><var><a name="index-g_t_0024target_005fname-arp_005fpoll-183"></a></var><br>
&mdash; Command: <b>$target_name arp_reset</b><var><a name="index-g_t_0024target_005fname-arp_005freset-184"></a></var><br>
&mdash; Command: <b>$target_name arp_waitstate</b><var><a name="index-g_t_0024target_005fname-arp_005fwaitstate-185"></a></var><br>
<blockquote><p>Internal OpenOCD scripts (most notably <samp><span class="file">startup.tcl</span></samp>)
use these to deal with specific reset cases. 
They are not otherwise documented here. 
</p></blockquote></div>

<div class="defun">
&mdash; Command: <b>$target_name array2mem</b><var> arrayname width address count<a name="index-g_t_0024target_005fname-array2mem-186"></a></var><br>
&mdash; Command: <b>$target_name mem2array</b><var> arrayname width address count<a name="index-g_t_0024target_005fname-mem2array-187"></a></var><br>
<blockquote><p>These provide an efficient script-oriented interface to memory. 
The <code>array2mem</code> primitive writes bytes, halfwords, or words;
while <code>mem2array</code> reads them. 
In both cases, the TCL side uses an array, and
the target side uses raw memory.

     <p>The efficiency comes from enabling the use of
bulk JTAG data transfer operations. 
The script orientation comes from working with data
values that are packaged for use by TCL scripts;
<samp><span class="command">mdw</span></samp> type primitives only print data they retrieve,
and neither store nor return those values.

          <ul>
<li><var>arrayname</var> ... is the name of an array variable
<li><var>width</var> ... is 8/16/32 - indicating the memory access size
<li><var>address</var> ... is the target memory address
<li><var>count</var> ... is the number of elements to process
</ul>
     </p></blockquote></div>

<div class="defun">
&mdash; Command: <b>$target_name cget</b><var> queryparm<a name="index-g_t_0024target_005fname-cget-188"></a></var><br>
<blockquote><p>Each configuration parameter accepted by
<samp><span class="command">$target_name configure</span></samp>
can be individually queried, to return its current value. 
The <var>queryparm</var> is a parameter name
accepted by that command, such as <code>-work-area-phys</code>. 
There are a few special cases:

          <ul>
<li><code>-event</code> <var>event_name</var> &ndash; returns the handler for the
event named <var>event_name</var>. 
This is a special case because setting a handler requires
two parameters. 
<li><code>-type</code> &ndash; returns the target type. 
This is a special case because this is set using
<samp><span class="command">target create</span></samp> and can't be changed
using <samp><span class="command">$target_name configure</span></samp>. 
</ul>

     <p>For example, if you wanted to summarize information about
all the targets you might use something like this:

     <pre class="example">          foreach name [target names] {
              set y [$name cget -endian]
              set z [$name cget -type]
              puts [format "Chip %d is %s, Endian: %s, type: %s" \
                           $x $name $y $z]
          }
</pre>
     </blockquote></div>

<p><a name="target-curstate"></a>

<div class="defun">
&mdash; Command: <b>$target_name curstate</b><var><a name="index-g_t_0024target_005fname-curstate-189"></a></var><br>
<blockquote><p>Displays the current target state:
<code>debug-running</code>,
<code>halted</code>,
<code>reset</code>,
<code>running</code>, or <code>unknown</code>. 
(Also, see <a href="Event-Polling.html#Event-Polling">Event Polling</a>.) 
</p></blockquote></div>

<div class="defun">
&mdash; Command: <b>$target_name eventlist</b><var><a name="index-g_t_0024target_005fname-eventlist-190"></a></var><br>
<blockquote><p>Displays a table listing all event handlers
currently associated with this target. 
See <a href="Target-Events.html#Target-Events">Target Events</a>. 
</p></blockquote></div>

<div class="defun">
&mdash; Command: <b>$target_name invoke-event</b><var> event_name<a name="index-g_t_0024target_005fname-invoke_002devent-191"></a></var><br>
<blockquote><p>Invokes the handler for the event named <var>event_name</var>. 
(This is primarily intended for use by OpenOCD framework
code, for example by the reset code in <samp><span class="file">startup.tcl</span></samp>.) 
</p></blockquote></div>

<div class="defun">
&mdash; Command: <b>$target_name mdw</b><var> addr </var>[<var>count</var>]<var><a name="index-g_t_0024target_005fname-mdw-192"></a></var><br>
&mdash; Command: <b>$target_name mdh</b><var> addr </var>[<var>count</var>]<var><a name="index-g_t_0024target_005fname-mdh-193"></a></var><br>
&mdash; Command: <b>$target_name mdb</b><var> addr </var>[<var>count</var>]<var><a name="index-g_t_0024target_005fname-mdb-194"></a></var><br>
<blockquote><p>Display contents of address <var>addr</var>, as
32-bit words (<samp><span class="command">mdw</span></samp>), 16-bit halfwords (<samp><span class="command">mdh</span></samp>),
or 8-bit bytes (<samp><span class="command">mdb</span></samp>). 
If <var>count</var> is specified, displays that many units. 
(If you want to manipulate the data instead of displaying it,
see the <code>mem2array</code> primitives.) 
</p></blockquote></div>

<div class="defun">
&mdash; Command: <b>$target_name mww</b><var> addr word<a name="index-g_t_0024target_005fname-mww-195"></a></var><br>
&mdash; Command: <b>$target_name mwh</b><var> addr halfword<a name="index-g_t_0024target_005fname-mwh-196"></a></var><br>
&mdash; Command: <b>$target_name mwb</b><var> addr byte<a name="index-g_t_0024target_005fname-mwb-197"></a></var><br>
<blockquote><p>Writes the specified <var>word</var> (32 bits),
<var>halfword</var> (16 bits), or <var>byte</var> (8-bit) pattern,
at the specified address <var>addr</var>. 
</p></blockquote></div>

<p><a name="Target-Events"></a>

<h3 class="section">11.5 Target Events</h3>

<p><a name="index-target-events-198"></a><a name="index-events-199"></a>At various times, certain things can happen, or you want them to happen. 
For example:
     <ul>
<li>What should happen when GDB connects? Should your target reset? 
<li>When GDB tries to flash the target, do you need to enable the flash via a special command? 
<li>Is using SRST appropriate (and possible) on your system? 
Or instead of that, do you need to issue JTAG commands to trigger reset? 
SRST usually resets everything on the scan chain, which can be inappropriate. 
<li>During reset, do you need to write to certain memory locations
to set up system clocks or
to reconfigure the SDRAM? 
How about configuring the watchdog timer, or other peripherals,
to stop running while you hold the core stopped for debugging? 
</ul>

<p>All of the above items can be addressed by target event handlers. 
These are set up by <samp><span class="command">$target_name configure -event</span></samp> or
<samp><span class="command">target create ... -event</span></samp>.

<p>The programmer's model matches the <code>-command</code> option used in Tcl/Tk
buttons and events.  The two examples below act the same, but one creates
and invokes a small procedure while the other inlines it.

<pre class="example">     proc my_attach_proc { } {
         echo "Reset..."
         reset halt
     }
     mychip.cpu configure -event gdb-attach my_attach_proc
     mychip.cpu configure -event gdb-attach {
         echo "Reset..."
         # To make flash probe and gdb load to flash work we need a reset init.
         reset init
     }
</pre>
<p>The following target events are defined:

     <ul>
<li><b>debug-halted</b>
<br> The target has halted for debug reasons (i.e.: breakpoint)
<li><b>debug-resumed</b>
<br> The target has resumed (i.e.: gdb said run)
<li><b>early-halted</b>
<br> Occurs early in the halt process
<li><b>examine-start</b>
<br> Before target examine is called. 
<li><b>examine-end</b>
<br> After target examine is called with no errors. 
<li><b>gdb-attach</b>
<br> When GDB connects. This is before any communication with the target, so this
can be used to set up the target so it is possible to probe flash. Probing flash
is necessary during gdb connect if gdb load is to write the image to flash. Another
use of the flash memory map is for GDB to automatically hardware/software breakpoints
depending on whether the breakpoint is in RAM or read only memory. 
<li><b>gdb-detach</b>
<br> When GDB disconnects
<li><b>gdb-end</b>
<br> When the target has halted and GDB is not doing anything (see early halt)
<li><b>gdb-flash-erase-start</b>
<br> Before the GDB flash process tries to erase the flash
<li><b>gdb-flash-erase-end</b>
<br> After the GDB flash process has finished erasing the flash
<li><b>gdb-flash-write-start</b>
<br> Before GDB writes to the flash
<li><b>gdb-flash-write-end</b>
<br> After GDB writes to the flash
<li><b>gdb-start</b>
<br> Before the target steps, gdb is trying to start/resume the target
<li><b>halted</b>
<br> The target has halted
<li><b>reset-assert-pre</b>
<br> Issued as part of <samp><span class="command">reset</span></samp> processing
after <samp><span class="command">reset_init</span></samp> was triggered
but before either SRST alone is re-asserted on the scan chain,
or <code>reset-assert</code> is triggered. 
<li><b>reset-assert</b>
<br> Issued as part of <samp><span class="command">reset</span></samp> processing
after <samp><span class="command">reset-assert-pre</span></samp> was triggered. 
When such a handler is present, cores which support this event will use
it instead of asserting SRST. 
This support is essential for debugging with JTAG interfaces which
don't include an SRST line (JTAG doesn't require SRST), and for
selective reset on scan chains that have multiple targets. 
<li><b>reset-assert-post</b>
<br> Issued as part of <samp><span class="command">reset</span></samp> processing
after <code>reset-assert</code> has been triggered. 
or the target asserted SRST on the entire scan chain. 
<li><b>reset-deassert-pre</b>
<br> Issued as part of <samp><span class="command">reset</span></samp> processing
after <code>reset-assert-post</code> has been triggered. 
<li><b>reset-deassert-post</b>
<br> Issued as part of <samp><span class="command">reset</span></samp> processing
after <code>reset-deassert-pre</code> has been triggered
and (if the target is using it) after SRST has been
released on the scan chain. 
<li><b>reset-end</b>
<br> Issued as the final step in <samp><span class="command">reset</span></samp> processing. 
<li><b>reset-init</b>
<br> Used by <b>reset init</b> command for board-specific initialization. 
This event fires after <em>reset-deassert-post</em>.

     <p>This is where you would configure PLLs and clocking, set up DRAM so
you can download programs that don't fit in on-chip SRAM, set up pin
multiplexing, and so on. 
(You may be able to switch to a fast JTAG clock rate here, after
the target clocks are fully set up.) 
<li><b>reset-start</b>
<br> Issued as part of <samp><span class="command">reset</span></samp> processing
before <samp><span class="command">reset_init</span></samp> is called.

     <p>This is the most robust place to use <samp><span class="command">jtag_rclk</span></samp>
or <samp><span class="command">adapter_khz</span></samp> to switch to a low JTAG clock rate,
when reset disables PLLs needed to use a fast clock. 
<li><b>resume-start</b>
<br> Before any target is resumed
<li><b>resume-end</b>
<br> After all targets have resumed
<li><b>resumed</b>
<br> Target has resumed
</ul>

</body></html>

