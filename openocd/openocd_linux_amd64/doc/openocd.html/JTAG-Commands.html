<html lang="en">
<head>
<title>JTAG Commands - OpenOCD User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="OpenOCD User's Guide">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="prev" href="Architecture-and-Core-Commands.html#Architecture-and-Core-Commands" title="Architecture and Core Commands">
<link rel="next" href="Boundary-Scan-Commands.html#Boundary-Scan-Commands" title="Boundary Scan Commands">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This User's Guide documents
release 0.7.0-dev,
dated 25 March 2013,
of the Open On-Chip Debugger (OpenOCD).
   * Copyright (C) 2008 The OpenOCD Project

   * Copyright (C) 2007-2008 Spencer Oliver <spen@spen-soft.co.uk>

   * Copyright (C) 2008-2010 Oyvind Harboe <oyvind.harboe@zylin.com>

   * Copyright (C) 2008 Duane Ellis <openocd@duaneellis.com>

   * Copyright (C) 2009-2010 David Brownell
     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with no Front-Cover Texts,
     and with no Back-Cover Texts.  A copy of the license is included
     in the section entitled ``GNU Free Documentation License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="JTAG-Commands"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Boundary-Scan-Commands.html#Boundary-Scan-Commands">Boundary Scan Commands</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Architecture-and-Core-Commands.html#Architecture-and-Core-Commands">Architecture and Core Commands</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="index.html#Top">Top</a>
<hr>
</div>

<h2 class="chapter">18 JTAG Commands</h2>

<p><a name="index-JTAG-Commands-507"></a>Most general purpose JTAG commands have been presented earlier. 
(See <a href="JTAG-Speed.html#JTAG-Speed">JTAG Speed</a>, <a href="Reset-Configuration.html#Reset-Configuration">Reset Configuration</a>, and <a href="TAP-Declaration.html#TAP-Declaration">TAP Declaration</a>.) 
Lower level JTAG commands, as presented here,
may be needed to work with targets which require special
attention during operations such as reset or initialization.

<p>To use these commands you will need to understand some
of the basics of JTAG, including:

     <ul>
<li>A JTAG scan chain consists of a sequence of individual TAP
devices such as a CPUs. 
<li>Control operations involve moving each TAP through the same
standard state machine (in parallel)
using their shared TMS and clock signals. 
<li>Data transfer involves shifting data through the chain of
instruction or data registers of each TAP, writing new register values
while the reading previous ones. 
<li>Data register sizes are a function of the instruction active in
a given TAP, while instruction register sizes are fixed for each TAP. 
All TAPs support a BYPASS instruction with a single bit data register. 
<li>The way OpenOCD differentiates between TAP devices is by
shifting different instructions into (and out of) their instruction
registers. 
</ul>

<h3 class="section">18.1 Low Level JTAG Commands</h3>

<p>These commands are used by developers who need to access
JTAG instruction or data registers, possibly controlling
the order of TAP state transitions. 
If you're not debugging OpenOCD internals, or bringing up a
new JTAG adapter or a new type of TAP device (like a CPU or
JTAG router), you probably won't need to use these commands. 
In a debug session that doesn't use JTAG for its transport protocol,
these commands are not available.

<div class="defun">
&mdash; Command: <b>drscan</b><var> tap </var>[<var>numbits value</var>]<var>+ </var>[<samp><span class="option">-endstate</span></samp><var> tap_state</var>]<var><a name="index-drscan-508"></a></var><br>
<blockquote><p>Loads the data register of <var>tap</var> with a series of bit fields
that specify the entire register. 
Each field is <var>numbits</var> bits long with
a numeric <var>value</var> (hexadecimal encouraged). 
The return value holds the original value of each
of those fields.

     <p>For example, a 38 bit number might be specified as one
field of 32 bits then one of 6 bits. 
<em>For portability, never pass fields which are more
than 32 bits long.  Many OpenOCD implementations do not
support 64-bit (or larger) integer values.</em>

     <p>All TAPs other than <var>tap</var> must be in BYPASS mode. 
The single bit in their data registers does not matter.

     <p>When <var>tap_state</var> is specified, the JTAG state machine is left
in that state. 
For example <span class="sc">drpause</span> might be specified, so that more
instructions can be issued before re-entering the <span class="sc">run/idle</span> state. 
If the end state is not specified, the <span class="sc">run/idle</span> state is entered.

     <blockquote>
<b>Warning:</b> OpenOCD does not record information about data register lengths,
so <em>it is important that you get the bit field lengths right</em>. 
Remember that different JTAG instructions refer to different
data registers, which may have different lengths. 
Moreover, those lengths may not be fixed;
the SCAN_N instruction can change the length of
the register accessed by the INTEST instruction
(by connecting a different scan chain). 
</blockquote>
     </p></blockquote></div>

<div class="defun">
&mdash; Command: <b>flush_count</b><var><a name="index-flush_005fcount-509"></a></var><br>
<blockquote><p>Returns the number of times the JTAG queue has been flushed. 
This may be used for performance tuning.

     <p>For example, flushing a queue over USB involves a
minimum latency, often several milliseconds, which does
not change with the amount of data which is written. 
You may be able to identify performance problems by finding
tasks which waste bandwidth by flushing small transfers too often,
instead of batching them into larger operations. 
</p></blockquote></div>

<div class="defun">
&mdash; Command: <b>irscan</b> [<var>tap instruction</var>]<var>+ </var>[<samp><span class="option">-endstate</span></samp><var> tap_state</var>]<var><a name="index-irscan-510"></a></var><br>
<blockquote><p>For each <var>tap</var> listed, loads the instruction register
with its associated numeric <var>instruction</var>. 
(The number of bits in that instruction may be displayed
using the <samp><span class="command">scan_chain</span></samp> command.) 
For other TAPs, a BYPASS instruction is loaded.

     <p>When <var>tap_state</var> is specified, the JTAG state machine is left
in that state. 
For example <span class="sc">irpause</span> might be specified, so the data register
can be loaded before re-entering the <span class="sc">run/idle</span> state. 
If the end state is not specified, the <span class="sc">run/idle</span> state is entered.

     <blockquote>
<b>Note:</b> OpenOCD currently supports only a single field for instruction
register values, unlike data register values. 
For TAPs where the instruction register length is more than 32 bits,
portable scripts currently must issue only BYPASS instructions. 
</blockquote>
     </p></blockquote></div>

<div class="defun">
&mdash; Command: <b>jtag_reset</b><var> trst srst<a name="index-jtag_005freset-511"></a></var><br>
<blockquote><p>Set values of reset signals. 
The <var>trst</var> and <var>srst</var> parameter values may be
<samp><span class="option">0</span></samp>, indicating that reset is inactive (pulled or driven high),
or <samp><span class="option">1</span></samp>, indicating it is active (pulled or driven low). 
The <samp><span class="command">reset_config</span></samp> command should already have been used
to configure how the board and JTAG adapter treat these two
signals, and to say if either signal is even present. 
See <a href="Reset-Configuration.html#Reset-Configuration">Reset Configuration</a>.

     <p>Note that TRST is specially handled. 
It actually signifies JTAG's <span class="sc">reset</span> state. 
So if the board doesn't support the optional TRST signal,
or it doesn't support it along with the specified SRST value,
JTAG reset is triggered with TMS and TCK signals
instead of the TRST signal. 
And no matter how that JTAG reset is triggered, once
the scan chain enters <span class="sc">reset</span> with TRST inactive,
TAP <code>post-reset</code> events are delivered to all TAPs
with handlers for that event. 
</p></blockquote></div>

<div class="defun">
&mdash; Command: <b>pathmove</b><var> start_state </var>[<var>next_state ...</var>]<var><a name="index-pathmove-512"></a></var><br>
<blockquote><p>Start by moving to <var>start_state</var>, which
must be one of the <em>stable</em> states. 
Unless it is the only state given, this will often be the
current state, so that no TCK transitions are needed. 
Then, in a series of single state transitions
(conforming to the JTAG state machine) shift to
each <var>next_state</var> in sequence, one per TCK cycle. 
The final state must also be stable. 
</p></blockquote></div>

<div class="defun">
&mdash; Command: <b>runtest</b><var> num_cycles<a name="index-runtest-513"></a></var><br>
<blockquote><p>Move to the <span class="sc">run/idle</span> state, and execute at least
<var>num_cycles</var> of the JTAG clock (TCK). 
Instructions often need some time
to execute before they take effect. 
</p></blockquote></div>

<!-- tms_sequence (short|long) -->
<!-- ... temporary, debug-only, other than USBprog bug workaround... -->
<div class="defun">
&mdash; Command: <b>verify_ircapture</b> (<samp><span class="option">enable</span></samp><var>|</var><samp><span class="option">disable</span></samp>)<var><a name="index-verify_005fircapture-514"></a></var><br>
<blockquote><p>Verify values captured during <span class="sc">ircapture</span> and returned
during IR scans.  Default is enabled, but this can be
overridden by <samp><span class="command">verify_jtag</span></samp>. 
This flag is ignored when validating JTAG chain configuration. 
</p></blockquote></div>

<div class="defun">
&mdash; Command: <b>verify_jtag</b> (<samp><span class="option">enable</span></samp><var>|</var><samp><span class="option">disable</span></samp>)<var><a name="index-verify_005fjtag-515"></a></var><br>
<blockquote><p>Enables verification of DR and IR scans, to help detect
programming errors.  For IR scans, <samp><span class="command">verify_ircapture</span></samp>
must also be enabled. 
Default is enabled. 
</p></blockquote></div>

<h3 class="section">18.2 TAP state names</h3>

<p><a name="index-TAP-state-names-516"></a>
The <var>tap_state</var> names used by OpenOCD in the <samp><span class="command">drscan</span></samp>,
<samp><span class="command">irscan</span></samp>, and <samp><span class="command">pathmove</span></samp> commands are the same
as those used in SVF boundary scan documents, except that
SVF uses <span class="sc">idle</span> instead of <span class="sc">run/idle</span>.

     <ul>
<li><b>RESET</b> ... <em>stable</em> (with TMS high);
acts as if TRST were pulsed
<li><b>RUN/IDLE</b> ... <em>stable</em>; don't assume this always means IDLE
<li><b>DRSELECT</b>
<li><b>DRCAPTURE</b>
<li><b>DRSHIFT</b> ... <em>stable</em>; TDI/TDO shifting
through the data register
<li><b>DREXIT1</b>
<li><b>DRPAUSE</b> ... <em>stable</em>; data register ready
for update or more shifting
<li><b>DREXIT2</b>
<li><b>DRUPDATE</b>
<li><b>IRSELECT</b>
<li><b>IRCAPTURE</b>
<li><b>IRSHIFT</b> ... <em>stable</em>; TDI/TDO shifting
through the instruction register
<li><b>IREXIT1</b>
<li><b>IRPAUSE</b> ... <em>stable</em>; instruction register ready
for update or more shifting
<li><b>IREXIT2</b>
<li><b>IRUPDATE</b>
</ul>

<p>Note that only six of those states are fully &ldquo;stable&rdquo; in the
face of TMS fixed (low except for <span class="sc">reset</span>)
and a free-running JTAG clock.  For all the
others, the next TCK transition changes to a new state.

     <ul>
<li>From <span class="sc">drshift</span> and <span class="sc">irshift</span>, clock transitions will
produce side effects by changing register contents.  The values
to be latched in upcoming <span class="sc">drupdate</span> or <span class="sc">irupdate</span> states
may not be as expected. 
<li><span class="sc">run/idle</span>, <span class="sc">drpause</span>, and <span class="sc">irpause</span> are reasonable
choices after <samp><span class="command">drscan</span></samp> or <samp><span class="command">irscan</span></samp> commands,
since they are free of JTAG side effects. 
<li><span class="sc">run/idle</span> may have side effects that appear at non-JTAG
levels, such as advancing the ARM9E-S instruction pipeline. 
Consult the documentation for the TAP(s) you are working with. 
</ul>

</body></html>

